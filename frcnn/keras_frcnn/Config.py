import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' 
# rom __future__ import division
# from __future__ import print_function
# from __future__ import absolute_import
import random
import pprint
import sys
import time
import numpy as np
import pickle
import math
import cv2
import copy
from matplotlib import pyplot as plt
import tensorflow as tf
import pandas as pd
import os

class Config:

    def __init__(self):

        # Print the process or not
        self.verbose = True

        # Name of base network
        self.network = 'mobilenetv1'
        # Position of image to display on debug
        self.viewPos = 1
        self.classView = 1
        # Resize anchors
        self.scaler = 0.7
        # Learning Rate
        self.epsilon = 4e-4
         # Set epochs for training
        self.epochs = 20

        # Setting for data augmentation
        self.use_horizontal_flips = False
        self.use_vertical_flips = False
        self.rot_90 = False
        
        # Anchor box scales 
        # Note that if im_size is smaller, anchor_box_scales should be scaled
        # Original anchor_box_scales in the paper is [128, 256, 512]
        self.anchor_box_scales = [int(64*(self.scaler)), int(128*(self.scaler)), int(256*(self.scaler))] 
        # Anchor box ratios
        self.anchor_box_ratios = [[1, 1], [1.4/math.sqrt(2), 1.7/math.sqrt(2)], [1.7/math.sqrt(2), 1.4/math.sqrt(2)]]
        # self.anchor_box_ratios =[[1./math.sqrt(2),1./math.sqrt(2)], [1./math.sqrt(2), 2./math.sqrt(2)], [2./math.sqrt(2), 1./math.sqrt(2)]]
        # self.anchor_box_ratios =[[1./math.sqrt(2),1./math.sqrt(2)], [1./math.sqrt(2), 2./math.sqrt(2)], [2./math.sqrt(2), 1./math.sqrt(2)]]
        # self.anchor_box_ratios =[[1./math.sqrt(2), 1.2/math.sqrt(2)], [1.2/math.sqrt(2), 1./math.sqrt(2)],[1./math.sqrt(2), 2./math.sqrt(2)],[2./math.sqrt(2), 1./math.sqrt(2)]]
        # self.anchor_box_ratios =[[1.2,1.2/math.sqrt(2)], [1.2/math.sqrt(2), 1.2],[1./math.sqrt(2), 3./math.sqrt(2)],[3./math.sqrt(2), 1./math.sqrt(2)]]
        # self.anchor_box_ratios =[[1,1], [1, 2], [2, 1]]
        # Size to resize the smallest side of the image
        # Original setting in paper is 600. Set to 300 in here to save training time
        self.im_size = 224
        
        # image channel-wise mean to subtract
        self.img_channel_mean = [103.939, 116.779, 123.68]
        self.img_scaling_factor = 1.0

        # number of ROIs at once
        self.num_rois = 4

        # stride at the RPN (this depends on the network configuration)
        self.rpn_stride = 16

        self.balanced_classes = False

        # scaling the stdev
        self.std_scaling = 4.0
        self.classifier_regr_std = [8.0, 8.0, 4.0, 4.0]

        # overlaps for RPN
        self.rpn_min_overlap = 0.3
        self.rpn_max_overlap = 0.8

        # overlaps for classifier ROIs
        self.classifier_min_overlap = 0.1
        self.classifier_max_overlap = 0.5

        # placeholder for the class mapping, automatically generated by the parser
        self.class_mapping = None
        self.model_path = None